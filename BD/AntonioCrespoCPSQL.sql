DROP DATABASE IF EXISTS COLEGIO;
CREATE DATABASE COLEGIO;
USE COLEGIO;

#TABLA CURSO
CREATE TABLE CURSO(
ANHO_INICIO YEAR PRIMARY KEY,
FINALIZADO BOOLEAN NOT NULL
);

INSERT INTO CURSO (ANHO_INICIO, FINALIZADO)VALUES
(2000, TRUE), (2001,TRUE), (2002, TRUE), (2003, TRUE),
(2004, TRUE),(2005, TRUE),(2006, TRUE),(2007, TRUE),
(2008, TRUE);

#TABLA ALUMNO
CREATE TABLE ALUMNO(
DNI CHAR(9) PRIMARY KEY,
NOMBRE_APE VARCHAR(50) NOT NULL,
TLF INT(9) NOT NULL,
FECHA_NAC DATE NOT NULL
);

INSERT INTO ALUMNO(DNI, NOMBRE_APE, TLF, FECHA_NAC)VALUES
('11111111H','PEPE',111111111, '1900-01-01'),('22222222J','JUAN',222222222,'1870-02-02'),
('33333333P','RAMÓN',333333333,'1689-03-03'),('44444444A','PATRICIA',444444444,'1999-04-04'),
('55555555K','ALBERTO',555555555,'2000-05-05'),('66666666Q','LAURA',666666666,'1969-06-06'),
('77777777B','NOA',777777777,'2002-06-18'),('88888888Y','MANOLO',888888888,'2001-04-30'),
('99999999R','LUCÍA',999999999,'2003-01-03');

#TABLA PROFESOR
CREATE TABLE PROFESOR(
NRP CHAR(15) PRIMARY KEY,
NOMBRE_APE VARCHAR(50) NOT NULL
);

INSERT INTO PROFESOR (NRP, NOMBRE_APE) VALUES
('1234567824A0590','ANTONIO GARCÍA'),('2111527457A0590','JULIAN ROMERO'),
('8765432168A0590','BEGOÑA CAMINOS'),('7395729457A0590','JOSE LUIS PERALES'),
('0192837402A0590','MARÍA ESPERANZA'),('3729461035A0590','CONCEPCIÓN DE LA CRUZ'),
('5687343902A0590','DANIEL RESUA'),('7654893402A0590','OSCAR FERNÁNDEZ');

#TABLA CICLO
CREATE TABLE CICLO(
ID INT PRIMARY KEY AUTO_INCREMENT,
NOMBRE VARCHAR(30) NOT NULL UNIQUE,
FAMILIA VARCHAR(20) NOT NULL,
GRADO ENUM('SUPERIOR','MEDIO')NOT NULL,
TUTOR CHAR(15) NOT NULL,
FOREIGN KEY(TUTOR)REFERENCES PROFESOR(NRP)
ON DELETE RESTRICT
ON UPDATE CASCADE
);

INSERT INTO CICLO(NOMBRE, FAMILIA, GRADO, TUTOR) VALUES
('DAM','INFORMATICA','SUPERIOR','1234567824A0590'),('DAW','INFORMATICA','SUPERIOR','2111527457A0590'),
('REDES','INFORMATICA','MEDIO','8765432168A0590'),('TELECO','INFORMATICA','MEDIO','7395729457A0590'),
('MICROINFORMATICA','INFORMATICA','SUPERIOR','1234567824A0590'),('ASIR','INFORMATICA','MEDIO','2111527457A0590');

#TABLA MATRICULA
CREATE TABLE MATRICULA(
DNI_ALUMNO CHAR(9),
ID_CICLO INT,
CURSO YEAR,
FECHA_ENTREGA DATE NOT NULL,
FECHA_BAJA DATE,
PRIMARY KEY(DNI_ALUMNO, ID_CICLO, CURSO),
FOREIGN KEY(DNI_ALUMNO)REFERENCES ALUMNO(DNI)
ON DELETE RESTRICT
ON UPDATE CASCADE,
FOREIGN KEY(ID_CICLO)REFERENCES CICLO(ID)
ON DELETE RESTRICT
ON UPDATE CASCADE,
FOREIGN KEY(CURSO)REFERENCES CURSO(ANHO_INICIO)
ON DELETE RESTRICT
ON UPDATE CASCADE
);

INSERT INTO MATRICULA(DNI_ALUMNO, ID_CICLO, CURSO, FECHA_ENTREGA)VALUES
('11111111H',1,'2000','1987-09-09'),('22222222J',2,'2001','1867-06-01'),('44444444A',3,'2002','2000-07-02');

#TABLA MODULO
CREATE TABLE MODULO(
ID INT PRIMARY KEY AUTO_INCREMENT,
NOMBRE VARCHAR(20) NOT NULL UNIQUE,
CURSO ENUM('1º','2º') NOT NULL,
SESIONES_SEM INT NOT NULL,
HORAS_ANU INT NOT NULL,
CICLO INT NOT NULL,
PROFESOR CHAR(15) NOT NULL,
FOREIGN KEY(CICLO)REFERENCES CICLO(ID)
ON DELETE CASCADE
ON UPDATE CASCADE,
FOREIGN KEY(PROFESOR)REFERENCES PROFESOR(NRP)
ON DELETE RESTRICT
ON UPDATE CASCADE
);

INSERT INTO MODULO(NOMBRE,CURSO,SESIONES_SEM,HORAS_ANU,CICLO,PROFESOR)VALUES
('SISTEMAS','1º',5,1200,1,'1234567824A0590'),('BBDD','1º',4,1000,1,'2111527457A0590'),('PAGINAS WEB','2º',8,2000,2,'0192837402A0590');

#TABLA ALUMNO_MODULO
CREATE TABLE ALUMNO_MODULO(
ALUMNO CHAR(9),
MODULO INT,
CURSO YEAR,
FECHA_PEC DATE,
ENVIADO_PEC DATE,
FALTAS INT NOT NULL DEFAULT 0,
NOTA INT,
PRIMARY KEY(ALUMNO, MODULO, CURSO),
FOREIGN KEY(ALUMNO)REFERENCES ALUMNO(DNI)
ON DELETE CASCADE
ON UPDATE CASCADE,
FOREIGN KEY (MODULO)REFERENCES MODULO(ID)
ON DELETE RESTRICT
ON UPDATE CASCADE,
FOREIGN KEY(CURSO)REFERENCES CURSO(ANHO_INICIO)
ON DELETE RESTRICT
ON UPDATE CASCADE,

CHECK (NOTA >=0),
CHECK (NOTA <=10)
);

INSERT INTO ALUMNO_MODULO (ALUMNO, MODULO, CURSO, FECHA_PEC, ENVIADO_PEC,FALTAS)VALUES
('11111111H',1,2000,NULL,NULL,0),('22222222J',3,'2002',NULL,NULL,0);


#-------------------------------------------------------------------------------------
/*MOSTRAR PARA EL CURSO ACTUAL LOS PROFESORES QUE ESTÁN IMPARTIENDO MENOS DE 20 
 *SESIONES SEMANALES*/

#CREAMOS UN CURSO MÁS ACTUALIZADO
INSERT INTO CURSO (ANHO_INICIO,FINALIZADO)VALUES
(YEAR(CURDATE()),FALSE);

#LOS PROFESORES CONCEPCIÓN DE LA CRUZ Y DANIEL RESUA NO SALDRÍAN EN LA CONSULTA, YA QUE TIENEN 20 Y 21 RESPECTIVAMENTE
INSERT INTO MODULO (NOMBRE,CURSO,SESIONES_SEM,HORAS_ANU,CICLO,PROFESOR)VALUES
('ANTENAS','2º',10,1000,4,'3729461035A0590'),('ONDAS SENO','1º',10,1000,4,'3729461035A0590'),
('DIRECCIONAMIENTO','2º',21,2000,3,'5687343902A0590');

#LOS PROFES BEGOÑA CAMINOS Y OSCAR FERNANDEZ DEBERÍAN SALIR EN LA CONSULTA
INSERT INTO MODULO (NOMBRE,CURSO,SESIONES_SEM,HORAS_ANU,CICLO,PROFESOR)VALUES
('MICRO PCS','2º',19,2000,5,'8765432168A0590'),('RISAS','1º',10,1000,6,'7654893402A0590');

#ALUMNOS PARA MATRICULAR EN EL CURSO ACTUAL Y EN LOS MODULOS
INSERT INTO ALUMNO (DNI,NOMBRE_APE,TLF,FECHA_NAC)VALUES
('94312012H','ALUMNO_ACTUAL1','101010101','2002-05-26'),('12121212A','ALUMNO_ACTUAL2','202020202','2000-01-02'),
('10203040K','ALUMNO_ACTUAL3','123456788','1990-03-04'),('90909090A','ALUMNO_ACTUAL4','999999998','200-03-09');

INSERT INTO MATRICULA (DNI_ALUMNO,ID_CICLO,CURSO,FECHA_ENTREGA)VALUES
('94312012H',4,YEAR(CURDATE()),'2021-07-01'),('12121212A',3,YEAR(CURDATE()),'2021-07-01'),
('10203040K',5,YEAR(CURDATE()),'2021-07-01'),('90909090A',6,YEAR(CURDATE()),'2021-07-01');

INSERT INTO ALUMNO_MODULO (ALUMNO,MODULO,CURSO)VALUES
('94312012H',4,YEAR(CURDATE())),('94312012H',5,YEAR(CURDATE())),
('12121212A',6,YEAR(CURDATE())),('10203040K',7,YEAR(CURDATE())),
('90909090A',8,YEAR(CURDATE()));

#EN EL AÑO ACTUAL DEBERÍAN SALIR SOLO BEGOÑA Y OSCAR
#CONSULTA:
SELECT * FROM 
(SELECT P.* , SUM(M.SESIONES_SEM)AS NUM_SES_TOT FROM PROFESOR P 
JOIN MODULO M ON M.PROFESOR = P.NRP 
JOIN ALUMNO_MODULO AM ON AM.MODULO = M.ID 
JOIN CURSO C ON AM.CURSO = C.ANHO_INICIO  
WHERE C.FINALIZADO IS FALSE GROUP BY P.NRP) AS C1
WHERE NUM_SES_TOT<20;

#-------------------------------------------------------------------------------------
/*
*MOSTRAR PARA EL CURSO ACTUAL, EL NÚMERO DE ALUMNOS POR MÓDULO CON 
*EL PROFESOR QUE LO IMPARTE EN LA ACTUALIDAD. SE DEBEN CONTAR LOS 
*ALUMNOS QUE HAN PERDIDO EL DERECHO A LA EVALUACIÓN CONTINUA, PERO 
*NO AQUELLOS QUE HAYAN SIDO DADOS DE BAJA EN EL CICLO
**/
#LAS ASIGNATURAS DEL CURSO ACTUAL SON LAS MISMAS QUE EN EL EJERCICIO ANTERIOR
#VAMOS A AÑADIR ALGÚN ALUMNO Y LE QUITAREMOS EL DERECHO A EVALUACIÓN CONTINUA EN LA ASIGNATURA DE DIRECCIONAMIENTO PARA QUE SALGAN 2
#A DEMÁS CREAREMOS UN ALUMNO EN LA DE ANTENAS Y LO DAREMOS DE BAJA PARA QUE SIGA SIENDO 1
INSERT INTO ALUMNO (DNI,NOMBRE_APE,TLF,FECHA_NAC)VALUES
('23423423L','ALUMNO_EN_DIRECC','121298985','1999-12-25'),('10203040T','ALUMNO_BAJA','999111333','1998-12-05');

INSERT INTO MATRICULA (DNI_ALUMNO,ID_CICLO,CURSO,FECHA_ENTREGA,FECHA_BAJA)VALUES
('23423423L',3,YEAR(CURDATE()),'2021-12-12',NULL),('10203040T',4,YEAR(CURDATE()),'2021-12-12','2022-05-23');

INSERT INTO ALUMNO_MODULO(ALUMNO,MODULO,CURSO,FECHA_PEC,ENVIADO_PEC,FALTAS)VALUES
('10203040T',4,YEAR(CURDATE()),'2022-05-01','2022-04-20',90),('23423423L',6,YEAR(CURDATE()),NULL,NULL,0);

#CONSULTA:

SELECT M.NOMBRE , COUNT(AM.ALUMNO)AS TOTAL_DE_ALUMNOS, P.NOMBRE_APE  FROM MODULO M 
JOIN ALUMNO_MODULO AM ON M.ID = AM.MODULO 
JOIN ALUMNO A ON A.DNI = AM.ALUMNO 
JOIN MATRICULA M2 ON M2.DNI_ALUMNO =A.DNI 
JOIN PROFESOR P ON P.NRP =M.PROFESOR
JOIN CURSO C ON C.ANHO_INICIO = M2.CURSO 
WHERE M2.FECHA_BAJA IS NULL AND C.FINALIZADO IS FALSE GROUP BY M.ID ; 

#-------------------------------------------------------------------------------------
/*MOSTRAR EL PORCENTAJE DE APROBADOS EN EL MÓDULO “PROGRAMACIÓN” EN TODOS LOS CURSOS YA FINALIZADOS, 
 * SIN TENER EN CUENTA LAS BAJAS.
 * */
#LO PRIMERO ES CREAR EL MÓDULO DE PROGRAMACIÓN, QUE POR DEFECTO COJERÁ EL ID 9
INSERT INTO MODULO (NOMBRE,CURSO,SESIONES_SEM,HORAS_ANU,CICLO,PROFESOR)VALUES
('PROGRAMACIÓN','1º',8,40,1,'7395729457A0590');

#AHORA HAREMOS ALUMNOS PARA ANOTARLOS EN PROGRAMACIÓN, TANTO EN EL CURSO SIN FINALIZAR COMO EN OTROS YA FINALIZADOS Y DAREMOS DE BAJA A 1

INSERT INTO ALUMNO (DNI,NOMBRE_APE,TLF,FECHA_NAC)VALUES
('11958300W','ALUMNO_ANTIGUO1','111222777','2001-01-01'),('11758300P','ALUMNO_ANTIGUO2_BAJA','111222777','2001-01-01'),
('11958304W','ALUMNO_ANTIGUO3','111222777','2001-01-01'),('22958300W','ALUMNO_ANTIGUO4','111222777','2001-01-01'),
('11957300A','ALUMNO_NUEVO','111222777','2001-01-01');

INSERT INTO MATRICULA(DNI_ALUMNO,ID_CICLO,CURSO,FECHA_ENTREGA,FECHA_BAJA)VALUES 
('11958300W',1,'2006','2007-06-06',NULL),('11758300P',1,'2006','2007-06-06','2007-06-07'),
('11958304W',1,'2008','2007-06-06',NULL),('22958300W',1,'2008','2007-06-06',NULL),
('11957300A',1,YEAR(CURDATE()),'2007-06-06',NULL);

#VAMOS A PONER 3 NOTAS VÁLIDAS:9,7,2 
INSERT INTO ALUMNO_MODULO (ALUMNO,MODULO,CURSO,NOTA)VALUES
('11958300W',9,'2006',9),('11758300P',9,'2006',3),('11958304W',9,'2008',7),
('22958300W',9,'2008',2),('11957300A',9,YEAR(CURDATE()),5);

#EL CÁLCULO SERÍA 2/3*100 YA QUE HAY 3 NOTAS VÁLIDAS Y 2 APROBADAS
SELECT CONCAT(2/3*100,'%')AS PORC;
#CONSULTA:
SELECT CONCAT(
(SELECT COUNT(AM.NOTA) FROM MODULO M 
JOIN ALUMNO_MODULO AM ON M.ID = AM.MODULO 
JOIN CURSO C ON C.ANHO_INICIO = AM.CURSO
JOIN ALUMNO A ON A.DNI = AM.ALUMNO 
JOIN MATRICULA M2 ON M2.DNI_ALUMNO = A.DNI 
WHERE M.NOMBRE = 'PROGRAMACIÓN' AND C.FINALIZADO = TRUE AND M2.FECHA_BAJA  IS NULL AND AM.NOTA > 4)/
(SELECT COUNT(AM.NOTA) FROM MODULO M 
JOIN ALUMNO_MODULO AM ON M.ID = AM.MODULO 
JOIN CURSO C ON C.ANHO_INICIO = AM.CURSO
JOIN ALUMNO A ON A.DNI = AM.ALUMNO 
JOIN MATRICULA M2 ON M2.DNI_ALUMNO = A.DNI 
WHERE M.NOMBRE = 'PROGRAMACIÓN' AND C.FINALIZADO = TRUE AND M2.FECHA_BAJA  IS NULL) 
*100,'%')AS PORCENTAJE_APROBADOS ; 

#-------------------------------------------------------------------------------------
/*LISTAR PARA EL CURSO ACTUAL LOS ALUMNOS DE CADA MÓDULO A LOS QUE ES 
 * NECESARIO ENVIAR EL APERCIBIMIENTO DE PÉRDIDA DE DERECHO A LA EVALUACIÓN 
 * CONTINUA--> 10%
 * */
#VAMOS A CREAR UN PAR DE ALUMNOS POCO RESPONSABLES. UNO YA TENDRÁ FECHA DE APERCIBIMIENTO
INSERT INTO ALUMNO (DNI,NOMBRE_APE,TLF,FECHA_NAC)VALUES
('23213231J','DIVAD',127125634,'1999-09-19'),('03652916T','SACUL',196911112,'1998-01-09');

INSERT INTO MATRICULA (DNI_ALUMNO,ID_CICLO,CURSO,FECHA_ENTREGA)VALUES
('23213231J',3,YEAR(CURDATE()),'2021-05-26'),('03652916T',1,YEAR(CURDATE()),'2021-06-10');

INSERT INTO ALUMNO_MODULO (ALUMNO,MODULO,CURSO,FECHA_PEC,ENVIADO_PEC,FALTAS)VALUES
('23213231J',6,YEAR(CURDATE()),NULL,NULL,300),('03652916T',1,YEAR(CURDATE()),NULL,'2022-02-01',120);

#CON ESTOS DATOS DEBERÍA SALIR SOLAMENTE DIVAD YA QUE A SACUL YA SE LE HA ENVIADO EL APERCIBIMIENTO 

#CONSULTA:
SELECT A.* FROM MODULO M 
JOIN ALUMNO_MODULO AM ON M.ID = AM.MODULO 
JOIN ALUMNO A ON A.DNI = AM.ALUMNO
JOIN CURSO C ON C.ANHO_INICIO = AM.CURSO 
WHERE C.FINALIZADO IS FALSE AND AM.FALTAS/M.HORAS_ANU>=0.1 AND AM.ENVIADO_PEC  IS NULL AND AM.FECHA_PEC IS NULL;

SELECT * FROM CICLO C JOIN MODULO M ON M.CICLO =C.ID;

#-------------------------------------------------------------------------------------
/*SI ES NECESARIO, MODIFICAR LA BD PARA PODER CONOCER, POR CADA CURSO ACADÉMICO 
 * EN QUÉ CICLO SE MATRICULAN LOS ALUMNOS.
 * */
SELECT C.ANHO_INICIO AS CURSO_ACADEMICO, M.DNI_ALUMNO AS ALUMNO , C2.NOMBRE AS CICLO FROM MATRICULA M 
JOIN CURSO C ON M.CURSO =C.ANHO_INICIO 
JOIN CICLO C2 ON M.ID_CICLO = C2.ID;

#-------------------------------------------------------------------------------------
/*PROGRAMAR UNA FUNCIÓN QUE OBTENGA EL CÓDIGO DEL CURSO ACTUAL.
 * */
#ACTIVAMOS LA PINCHE VARIABLE GLOBAL
SET GLOBAL LOG_BIN_TRUST_FUNCTION_CREATORS = 1;

DELIMITER //
DROP FUNCTION IF EXISTS CURSO_ACTUAL //
CREATE FUNCTION CURSO_ACTUAL()
RETURNS YEAR
BEGIN
	DECLARE ANHO_ACTUAL YEAR;
	SELECT C.ANHO_INICIO INTO ANHO_ACTUAL FROM CURSO C WHERE C.FINALIZADO IS FALSE ORDER BY C.ANHO_INICIO DESC LIMIT 1;
	RETURN ANHO_ACTUAL;
END;
//
DELIMITER ;

SELECT CURSO_ACTUAL(); 

#-------------------------------------------------------------------------------------
/*PARA AQUELLOS ALUMNOS DEL CURSO ACTUAL QUE ESTÁN CURSANDO MÓDULOS QUE NO SE 
 * CORRESPONDEN CON EL CICLO QUE FIGURA EN SU IMPRESO DE MATRÍCULA, LISTAR LAS 
 * PAREJAS ALUMNO – MÓDULO. 
 * UTILIZAR LA FUNCIÓN PROGRAMADA EN EL PUNTO ANTERIOR
 * */
#LOS CICLOS RELACIONADOS CON LOS MÓDULOS SON:
SELECT C.ID AS ID_CICLO, C.NOMBRE, M.ID AS ID_MODULO, M.NOMBRE  FROM MODULO M JOIN CICLO C ON C.ID = M.CICLO;

#VAMOS A CREAR UN ALUMNO CON LA MATRICULA Y MODULOS ERRÓNEOS
INSERT INTO ALUMNO (DNI,NOMBRE_APE,TLF,FECHA_NAC)VALUES
('03621945Z','ALUMNO_ERRONEO',999888999,'1890-09-09');

INSERT INTO MATRICULA (DNI_ALUMNO,ID_CICLO,CURSO,FECHA_ENTREGA)
VALUES('03621945Z',2,YEAR(CURDATE()),'2021-09-09');

INSERT INTO ALUMNO_MODULO (ALUMNO,MODULO,CURSO)VALUES
('03621945Z',7,YEAR(CURDATE()));

#CONSULTA:
SELECT A.DNI, A.NOMBRE_APE , M2.ID , M2.NOMBRE  FROM ALUMNO A 
JOIN ALUMNO_MODULO AM ON AM.ALUMNO =A.DNI
JOIN MATRICULA M ON M.DNI_ALUMNO = A.DNI
JOIN MODULO M2 ON M2.ID =AM.MODULO 
WHERE M2.CICLO <>M.ID_CICLO AND M.CURSO =CURSO_ACTUAL() AND AM.CURSO =CURSO_ACTUAL();

#-------------------------------------------------------------------------------------
/*ESCRIBIR EL SQL NECESARIO PARA AÑADIR A LA BD UN MECANISMO QUE IMPIDA QUE UN 
 * ALUMNO CURSE MÓDULOS QUE NO SE CORRESPONDAN CON EL CICLO EN QUE SE HAYA 
 * MATRICULADO.*/


DELIMITER //
DROP TRIGGER IF EXISTS AJUSTA_MODULOS //
CREATE TRIGGER AJUSTA_MODULOS
AFTER INSERT ON ALUMNO_MODULO
FOR EACH ROW
BEGIN
	DECLARE ANHO YEAR;
	DECLARE CICLO_MODULO INT;
	DECLARE CICLO_MATRICULA INT;
	SET ANHO= NEW.CURSO;
	SELECT M.CICLO INTO CICLO_MODULO FROM MODULO M WHERE M.ID =NEW.MODULO;
	SELECT M.ID_CICLO INTO CICLO_MATRICULA FROM MATRICULA M WHERE M.ID_CICLO = CICLO_MODULO AND M.CURSO =ANHO AND M.DNI_ALUMNO =NEW.ALUMNO;
	IF CICLO_MATRICULA IS NULL THEN
		#CALL BORRA_MODULOS(NEW.ALUMNO, NEW.MODULO, NEW.CURSO);
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = "NO SE PUEDE METER AL ALUMNO EN EL MODULO YA QUE NO TIENE MATRICULA EN EL CORRESPONDIENTE CICLO";
	END IF;
END;
//

DROP PROCEDURE IF EXISTS BORRA_MODULOS //
CREATE PROCEDURE BORRA_MODULOS(IN AL_AUX CHAR(9), IN MOD_AUX INT, IN CUR_AUX YEAR) 
BEGIN
	DELETE FROM ALUMNO_MODULO AM WHERE AM.ALUMNO = AL_AUX AND AM.MODULO = MOD_AUX AND AM.CURSO =CUR_AUX;
END;
//
DELIMITER ;


#PARA COMPROBAR HAREMOS LO MISMO QUE ANTES, PONER UN ALUMNO ERRÓNEO.
#POR PEREZA COPIARE TAL CUAL EL DE ARRIBA Y LE CAMBIARE LA LETRA DEL DNI

INSERT INTO ALUMNO (DNI,NOMBRE_APE,TLF,FECHA_NAC)VALUES
('03621945I','ALUMNO_ERRONEO2',999888996,'1890-09-09');

INSERT INTO MATRICULA (DNI_ALUMNO,ID_CICLO,CURSO,FECHA_ENTREGA)
VALUES('03621945I',2,YEAR(CURDATE()),'2021-09-09');

#DESCOMENTAR PARA COMPROBAR QUE NO DEJA INSERTARLO. NOTA: SALTARÁ ERROR 
#INSERT INTO ALUMNO_MODULO (ALUMNO,MODULO,CURSO)VALUES
#('03621945I',7,YEAR(CURDATE()));

#-------------------------------------------------------------------------------------
/*ESCRIBIR EL SQL NECESARIO PARA AÑADIR A LA BD UN MECANISMO QUE IMPIDA MODIFICAR 
 *EL CICLO EN QUE ESTÁ MATRICULADO UN ALUMNO SI YA SE LE HA ASIGNADO ALGÚN MÓDULO.
 * */

DELIMITER //
DROP TRIGGER IF EXISTS MODIFICA_CICLO //
CREATE TRIGGER MODIFICA_CICLO
BEFORE UPDATE ON MATRICULA
FOR EACH ROW
BEGIN
	DECLARE CICLO_VIEJO INT;
	DECLARE CICLO_NUEVO INT;
	DECLARE MODULO_AUX INT;
	SET CICLO_VIEJO=OLD.ID_CICLO;
	SET CICLO_NUEVO=NEW.ID_CICLO;
	SELECT MODULO INTO MODULO_AUX FROM ALUMNO_MODULO AM WHERE AM.ALUMNO=NEW.DNI_ALUMNO AND AM.CURSO =NEW.CURSO LIMIT 1;
	IF (MODULO_AUX IS NOT NULL) AND (CICLO_VIEJO<>CICLO_NUEVO) THEN
		SET NEW.ID_CICLO=CICLO_VIEJO;
	END IF;
END;
//
DELIMITER ;

#VAMOS A REAPROVECHAR EL SIGUIENTE ALUMNO PARA PROBAR (11111111H)
#SU ÚNICO MÓDULO ES EL 1:
SELECT MODULO FROM ALUMNO_MODULO AM WHERE AM.ALUMNO ='11111111H';

#EL MÓDULO 1 SE CORRESPONDE CON EL CICLO 1:
SELECT * FROM CICLO C JOIN MODULO M ON C.ID = M.CICLO WHERE M.ID =1;

#LA MATRICULA DEL ALUMNO: 
SELECT * FROM MATRICULA M WHERE M.DNI_ALUMNO ='11111111H';

#PROCEDEREMOS A MODIFICAR DICHA MATRICULA:
UPDATE MATRICULA SET ID_CICLO =2 WHERE DNI_ALUMNO ='11111111H';

#COMO PODEMOS OBSERVAR LA MATRICULA SIGUE INTACTA:
SELECT * FROM MATRICULA M WHERE M.DNI_ALUMNO ='11111111H';

#-------------------------------------------------------------------------------------
/*¿HABRÍA ALGUNA FORMA DE INCORPORAR EN UN ÚNICO MECANISMO LAS DOS RESTRICCIONES 
 * ANTERIORES? EN CASO AFIRMATIVO, INDÍCALO*/

/*
DELIMITER //
DROP ASSERTION IF EXISTS CICLO_MODULO //
CREATE ASSERTION CICLO_MODULO
CHECK MODULO.CICLO=(SELECT C.ID FROM MODULO M 
JOIN ALUMNO_MODULO AM ON AM.MODULO = M.ID
JOIN ALUMNO A ON A.DNI = AM.ALUMNO 
JOIN MATRICULA M2 ON M2.DNI_ALUMNO = A.DNI
JOIN CICLO C ON C.ID =M2.ID_CICLO WHERE M.CICLO = C.ID );
//
DELIMITER ;
*/

#-------------------------------------------------------------------------------------
/*CREAR UNA VISTA QUE MUESTRE, PARA LOS MÓDULOS QUE IMPARTE EL PROFESOR CONECTADO AL 
 * SGBD, LOS ALUMNOS MATRICULADOS, SUS NOTAS Y SUS FALTAS
 * */

#LA FUNCIÓN CURRENT_USER DEVUELVE EL USUARIO CON EL QUE SE PERMITIÓ AUTENTIFICARSE
SELECT LEFT(CURRENT_USER(), INSTR(CURRENT_USER(), '@') - 1);

#SUPONIENDO QUE LOS PROFESORES SE REGISTRAN CON SU NRP:
DROP VIEW IF EXISTS ALUMNOS_PROFE;
CREATE VIEW ALUMNOS_PROFE AS 
(SELECT M.ID AS ID_MODULO, M.NOMBRE AS MODULO, A.DNI AS DNI_ALUMNO, 
A.NOMBRE_APE AS NOMBRE_ALUMNO, AM.NOTA, AM.FALTAS 
FROM MODULO M 
JOIN ALUMNO_MODULO AM ON M.ID = AM.MODULO 
JOIN ALUMNO A ON A.DNI = AM.ALUMNO  
WHERE M.PROFESOR = LEFT(CURRENT_USER(), INSTR(CURRENT_USER(), '@') - 1) AND AM.CURSO = CURSO_ACTUAL());

#-------------------------------------------------------------------------------------
/*CREAR UNA SEGUNDA VISTA QUE MUESTRE PARA EL PROFESOR CONECTADO AL SGBD, LOS ALUMNOS 
 * DE LOS QUE ES TUTOR, CON EL NÚMERO DE FALTAS POR MÓDULO Y LA INFORMACIÓN DE SI SE 
 * HA ENVIADO O NO EL APERCIBIMIENTO, O SI EL ALUMNO HA PERDIDO EL DERECHO A LA EVALUACIÓN 
 * CONTINUA, Y EN QUÉ FECHAS. --> '1234567824A0590' PARA PROBAR
 * */
DROP VIEW IF EXISTS ALUMNOS_TUTOR;
CREATE VIEW ALUMNOS_TUTOR AS
(SELECT A.DNI AS DNI_ALUMNO, A.NOMBRE_APE AS NOMBRE_ALUMNO, M2.ID AS ID_MODULO,
M2.NOMBRE AS MODULO, AM.FALTAS, AM.ENVIADO_PEC AS APERCIBIMIENTO, AM.FECHA_PEC AS FECHA_PERDIDA_EVAL_CONT 
FROM CICLO C 
JOIN MATRICULA M ON C.ID = M.ID_CICLO
JOIN ALUMNO A ON A.DNI = M.DNI_ALUMNO
JOIN ALUMNO_MODULO AM ON AM.ALUMNO = A.DNI
JOIN MODULO M2 ON AM.MODULO = M2.ID 
WHERE C.TUTOR = LEFT(CURRENT_USER(), INSTR(CURRENT_USER(), '@') - 1) AND M.CURSO = CURSO_ACTUAL());

#-------------------------------------------------------------------------------------
/*CREAR DOS ROLES EN LA BD: ADMINISTRADOR Y PROFESOR
 * */
DROP ROLE IF EXISTS ADMINISTRADOR;
DROP ROLE IF EXISTS PROFESOR;

CREATE ROLE ADMINISTRADOR;
CREATE ROLE PROFESOR;

#-------------------------------------------------------------------------------------
/*DEFINIR PERMISOS SOBRE LAS VISTAS ANTERIORES DE FORMA QUE LOS USUARIOS CON EL ROL PROFESOR 
 * SOLO PUEDAN MODIFICAR LAS NOTAS Y EL NÚMERO DE FALTAS DE LOS MÓDULOS QUE IMPARTEN Y LA 
 * INFORMACIÓN RELACIONADA CON LA PÉRDIDA DE DERECHO A LA EVALUACIÓN CONTINUA DE LOS ALUMNOS 
 * DE LOS QUE SON TUTORES. LOS USUARIOS CON EL ROLE ADMINISTRADOR TIENEN PERMISOS TOTALES 
 * SOBRE LAS MISMAS
 * */
GRANT ALL PRIVILEGES ON COLEGIO.* TO ADMINISTRADOR;

GRANT INSERT, DROP, SELECT, UPDATE ON ALUMNOS_PROFE TO PROFESOR;
GRANT INSERT, DROP, SELECT, UPDATE ON ALUMNOS_TUTOR TO PROFESOR;



DROP USER IF EXISTS '1234567824A0590'@'%';
CREATE USER '1234567824A0590'@'%' IDENTIFIED by 'profe1';
GRANT 'ADMINISTRADOR' TO '1234567824A0590'@'%';
#-------------------------------------------------------------------------------------
/*NO SE DEBE PERMITIR CERRAR UN CURSO ACADÉMICO SI EXISTEN ALUMNOS SIN CALIFICAR QUE NO 
 * HAYAN SIDO DADOS DE BAJA.
 * */
DELIMITER //
DROP TRIGGER IF EXISTS CHECK_CURSO //
CREATE TRIGGER CHECK_CURSO
BEFORE UPDATE ON CURSO
FOR EACH ROW
BEGIN
	DECLARE ALUMNO_AUX CHAR(9);
	IF (NEW.FINALIZADO IS TRUE) AND (OLD.FINALIZADO IS FALSE) THEN
		SELECT AM.ALUMNO INTO ALUMNO_AUX FROM ALUMNO_MODULO AM WHERE AM.CURSO = NEW.ANHO_INICIO AND AM.NOTA IS NULL LIMIT 1;
		IF ALUMNO_AUX IS NOT NULL THEN
			SET NEW.FINALIZADO=FALSE;
		END IF;
	END IF;
END;
//
DELIMITER ;


#-------------------------------------------------------------------------------------
/*CREAR UN PROCEDIMIENTO QUE PONGA LA NOTA QUE SE LE PASE COMO PARÁMETRO A AQUELLOS ALUMNOS 
 * DEL CURSO ACTUAL QUE NO TENGAN NOTA NI HAYAN SIDO DADOS DE BAJA. A CONTINUACIÓN DEBE 
 * FINALIZAR EL CURSO ACADÉMICO ACTUAL Y DAR DE ALTA EL SIGUIENTE.
 * */


DELIMITER //
DROP PROCEDURE IF EXISTS AUTO_NOTA //
CREATE PROCEDURE AUTO_NOTA(IN NOTA_GLOBAL INT)
BEGIN
	DECLARE ANHO_AUX YEAR;
	SET ANHO_AUX=CURSO_ACTUAL();
	UPDATE ALUMNO_MODULO SET NOTA = NOTA_GLOBAL WHERE CURSO = ANHO_AUX AND NOTA IS NULL;
	UPDATE CURSO SET FINALIZADO = TRUE WHERE ANHO_INICIO = ANHO_AUX;
	INSERT INTO CURSO(ANHO_INICIO,FINALIZADO)VALUES(ANHO_AUX + 1,FALSE);
END;
//

DELIMITER ;

#VAMOS A PROBAR LOS DOS ÚLTIMOS EJERCICIOS:
SELECT * FROM CURSO C WHERE C.ANHO_INICIO = CURSO_ACTUAL();

#UNO DE LOS ALUMNOS YA TIENE UN 5:
SELECT * FROM ALUMNO_MODULO AM WHERE AM.CURSO = CURSO_ACTUAL();

#CERRAMOS EL CURSO ACTUAL:
UPDATE CURSO SET FINALIZADO = TRUE WHERE ANHO_INICIO = CURSO_ACTUAL();

#AL HABER ALUMNOS SIN NOTAS NO ESTÁ PERMITIDO CERRARLO AÚN:
SELECT * FROM CURSO C WHERE C.ANHO_INICIO = CURSO_ACTUAL();

#VAMOS A RELLENAR EL RESTO DE NOTAS CON UN 7:
CALL AUTO_NOTA(7);



#