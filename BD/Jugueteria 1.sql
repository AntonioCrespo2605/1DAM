DROP DATABASE IF EXISTS JUGUETERIA;

CREATE DATABASE JUGUETERIA;

USE JUGUETERIA;

CREATE TABLE ARTICULO (
COD_ART VARCHAR(10) NOT NULL PRIMARY KEY,
DESCRIP TEXT NOT NULL,
UDS INT DEFAULT 0 NOT NULL,
PVENTA REAL NOT NULL,
CONSTRAINT CK_STOCK CHECK (UDS >= 0),
CONSTRAINT CK_PVENTA CHECK (PVENTA >= 0)
);

CREATE TABLE CAJERO (
NOMB_CAJ VARCHAR(10) NOT NULL PRIMARY KEY
);

CREATE TABLE REG_CAJA (
COD_REG INT NOT NULL PRIMARY KEY,
NOMB_CAJ VARCHAR(10) NOT NULL,
F_INICIO TIMESTAMP NOT NULL,
F_FIN TIMESTAMP,
CONSTRAINT FK_CAJERO FOREIGN KEY (NOMB_CAJ) REFERENCES CAJERO(NOMB_CAJ) ON DELETE NO ACTION ON UPDATE CASCADE,
CONSTRAINT CK_FECHAS CHECK (F_FIN > F_INICIO OR F_FIN IS NULL),
CONSTRAINT CK_FECHA_INICIO CHECK (F_INICIO >= '1.1.2015')
);

CREATE TABLE TICKET (
COD_TIC VARCHAR(20) NOT NULL PRIMARY KEY,
NOMB_CAJ VARCHAR(10) NOT NULL,
EFECTIVO BOOLEAN NOT NULL,
FECHA_HORA TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
CONSTRAINT FK_CAJERO_2 FOREIGN KEY (NOMB_CAJ) REFERENCES CAJERO(NOMB_CAJ) ON DELETE NO ACTION ON UPDATE CASCADE,
CONSTRAINT CK_FECHA CHECK (FECHA_HORA >= '1.1.2015')
);

CREATE TABLE TIC_ART (
COD_ART VARCHAR(10) NOT NULL,
COD_TIC VARCHAR(20) NOT NULL,
UDS INT NOT NULL,
CONSTRAINT PK_TIC_ART PRIMARY KEY (COD_ART,COD_TIC),
CONSTRAINT FK_ARTICULO FOREIGN KEY (COD_ART) REFERENCES ARTICULO(COD_ART) ON DELETE NO ACTION ON UPDATE CASCADE,
CONSTRAINT FK_TICKET FOREIGN KEY (COD_TIC) REFERENCES TICKET(COD_TIC) ON DELETE CASCADE ON UPDATE CASCADE
# CONSTRAINT CK_UDS CHECK (UDS > 0 AND UDS <=( SELECT ARTICULO.UDS FROM ARTICULO WHERE ARTICULO.COD_ART = TIC_ART.COD_ART)),
);

DELETE FROM ARTICULO ;
DELETE FROM CAJERO ;
DELETE FROM REG_CAJA ;
DELETE FROM TICKET ;
DELETE FROM TIC_ART ;

# INSERTAMOS VALORES EN LAS TABLAS PARA PROBAR LAS CONSULTAS
INSERT INTO ARTICULO(COD_ART, DESCRIP, UDS, PVENTA)
VALUES ('001', 'MUÑECO DE PLASTICO', 10, 15),
('002', 'PELOTA DE GOMA', 20, 20),
('003', 'PAQUETE DE PIEZAS MONTABLES', 35, 10.5),
('004', 'BARAJA DE CARTAS', 5, 5),
('005', 'PELUCHE', 14, 6),
('006', 'MINI FUTBOLIN', 2, 23),
('007', 'YO-YO', 25, 4),
('008', 'BICICLETA', 23, 199),
('009', 'MUÑECO DE ACCIÓN', 50, 25),
('010', 'MUÑECA', 32, 9.5),
('011', 'COMETA', 7, 8);

INSERT INTO CAJERO (NOMB_CAJ) VALUES ('JULIO'),('MARIA'),('EMILIO');

INSERT INTO REG_CAJA (COD_REG,NOMB_CAJ,F_INICIO,F_FIN)
VALUES (1,'JULIO','2015-01-06 10:00:00','2015-01-06 18:00:00'),
(2,'MARIA','2015-01-07 10:00:00','2015-01-07 18:00:00'),
(3,'JULIO','2015-01-08 10:00:00','2015-01-08 14:00:00'),
(4,'MARIA','2015-01-08 14:00:00','2015-01-08 18:00:00'),
(5,'JULIO','2015-01-09 10:00:00','2015-01-09 18:00:00'),
(6,'MARIA','2015-01-10 10:00:00','2015-01-10 18:00:00'),
(7,'JULIO','2015-01-11 10:00:00','2015-01-11 18:00:00'),
(8,'MARIA','2015-01-12 10:00:00','2015-01-12 18:00:00'),
(9,'EMILIO','2015-01-13 10:00:00','2015-01-13 18:00:00'),
(10,'JULIO','2015-01-14 10:00:00','2015-01-14 18:00:00'),
(11,'EMILIO','2015-01-15 10:00:00','2015-01-15 18:00:00'),
(12,'MARIA','2015-01-16 10:00:00','2015-01-16 18:00:00'),
(13,'JULIO','2015-01-01 10:00:00','2015-01-02 12:30:00' ),
(14,'MARIA','2016-05-01 10:00:00','2016-05-04 18:00:00'),
(15, 'MARIA', CURRENT_DATE, NULL);

INSERT INTO TICKET (COD_TIC,NOMB_CAJ,EFECTIVO,FECHA_HORA)
VALUES ('001', 'JULIO', 1, '2015-01-06 11:00:00'),
('002', 'JULIO', 1, '2015-01-08 13:00:00'),
('003', 'JULIO', 1, '2015-01-09 12:00:00'),
('004', 'JULIO', 1,'2015-01-14 10:30:00'),
('005', 'MARIA', 0, '2015-01-07 14:00:00'),
('006', 'MARIA', 0, '2015-01-07 17:00:00'),
('007', 'MARIA', 1, '2015-01-10 13:00:00'),
('008', 'MARIA', 1, '2015-01-10 11:30:00'),
('009', 'MARIA', 1, '2015-01-16 10:20:00'),
('010', 'EMILIO', 1, '2015-01-13 14:00:00'),
('011', 'EMILIO', 0, '2015-01-15 16:00:00'),
('012', 'MARIA', 0, '2016-05-01 14:00:00'),
('013', 'EMILIO', 1, '2016-05-01 14:00:00'),
('014', 'MARIA', 1, CURRENT_DATE),
('015', 'MARIA', 0, CURRENT_DATE),
('016', 'EMILIO', 1, CURRENT_DATE);

INSERT INTO TIC_ART (COD_ART,COD_TIC,UDS)
VALUES ('001', '001', 1),
('003', '002', 2),
('002', '003', 3),
('004', '004', 2),
('007', '004', 1),
('008', '005', 1),
('009', '006', 4),
('006', '007', 2),
('010', '008', 2),
('008', '009', 1),
('011', '010', 1),
('004', '011', 1),
('011','012',1),
('008', '014', 1),
('008', '015', 3),
('009','013',1),
('009','016',1);

/*
 * OBTENER A PARTIR DE LOS TICKETS DE CAJA EL IMPORTE TOTAL
 * VENDIDO EN EFECTIVO POR CADA EMPLEADO EN EL DÍA ACTUAL.
 */
SELECT NOMB_CAJ, SUM(A.PVENTA *TA.UDS) AS TOTAL
FROM TIC_ART TA INNER JOIN TICKET T ON TA.COD_TIC = T.COD_TIC  
INNER JOIN ARTICULO A ON TA.COD_ART =A.COD_ART  
WHERE T.FECHA_HORA  = CURRENT_DATE() AND T.EFECTIVO =1 GROUP BY NOMB_CAJ; 

/*
 * MOSTRAR EL NOMBRE DEL EMPLEADO QUE HA VENDIDO MÁS 
 * ARTÍCULOS DURANTE EL AÑO 2015.
 * */
SELECT NOMB_CAJ
FROM TICKET T INNER JOIN TIC_ART TA ON T.COD_TIC = TA.COD_TIC
WHERE EXTRACT(YEAR FROM FECHA_HORA) = 2015 GROUP BY NOMB_CAJ
HAVING SUM(UDS) = ( SELECT MAX(VENTAS2015) FROM ( SELECT SUM(UDS) AS VENTAS2015 FROM TICKET T2 INNER JOIN TIC_ART TA2
ON T2.COD_TIC = TA2.COD_TIC WHERE EXTRACT(YEAR FROM FECHA_HORA) = 2015 GROUP BY NOMB_CAJ ) AS VENTAS);

/*LISTAR LOS ARTÍCULOS QUE NO SE HAN VENDIDO EN EL MES 
 *DE MAYO DE 2016, ORDENADOS POR EL NÚMERO DE EXISTENCIAS, 
 *DE MAYOR A MENOR.
 */
SELECT * FROM ARTICULO A WHERE A.COD_ART NOT IN
( SELECT COD_ART FROM TICKET T INNER JOIN TIC_ART TA
ON T.COD_TIC = TA.COD_TIC WHERE CAST(FECHA_HORA AS DATE) BETWEEN '2016-05-01 00:00:00' AND '2016-05-31 23:59:59'
) ORDER BY UDS DESC;
/*
 * CREAR UNA CONSULTA QUE MUESTRE LOS CÓDIGOS DE TODOS LOS 
 * TICKETS ERRÓNEOS.
 */
SELECT TICKET.*
FROM TICKET, REG_CAJA
WHERE TICKET.NOMB_CAJ <> REG_CAJA.NOMB_CAJ AND FECHA_HORA
BETWEEN F_INICIO AND F_FIN;

/*
 *ESCRIBIR EL SQL NECESARIO PARA AÑADIR A LA BD UN MECANISMO
 *QUE VERIFIQUE QUE EL NOMBRE DEL USUARIO QUE FIGURA EN UN 
 *TICKET CUANDO SE CREA SE CORRESPONDE CON EL USUARIO QUE 
 *ESTÁ USANDO LA CAJA EN ESE MOMENTO.
 */

#DEVUELVE TODAS LAS FECHAS DE FIN Y LOS NOMBRES DE LOS CAJEROS
SELECT NOMB_CAJ, F_FIN  FROM REG_CAJA RC ;

#VARIABLE GLOBAL A TRUE
SET GLOBAL LOG_BIN_TRUST_FUNCTION_CREATORS = 1;

#DEVUELVE EL USUARIO QUE TIENE A NULL LA FECHA DE FIN
DELIMITER //
DROP FUNCTION IF EXISTS USUARIOACTUAL //
CREATE FUNCTION USUARIOACTUAL()
RETURNS VARCHAR(10)
BEGIN
DECLARE USUARIO VARCHAR(10);
SELECT NOMB_CAJ INTO USUARIO FROM REG_CAJA WHERE F_FIN IS NULL;
RETURN USUARIO;
END;
//
DELIMITER ;

#PARA COMPROBAR LA FUNCION
SELECT * FROM CAJERO C WHERE C.NOMB_CAJ = USUARIOACTUAL();

#SALTA CUANDO SE AÑADE UN TICKET Y COMPRUEBA EL CAJERO
DELIMITER //
DROP TRIGGER IF EXISTS COMPRUEBACAJERO //
CREATE TRIGGER COMPRUEBACAJERO
BEFORE INSERT ON TICKET
FOR EACH ROW
BEGIN
DECLARE CAJ_ACTUAL VARCHAR(10);
DECLARE CAJ_VIEJO VARCHAR(10);
DECLARE TICKET VARCHAR(10);
SET CAJ_VIEJO=NEW.NOMB_CAJ;
SET CAJ_ACTUAL=USUARIOACTUAL();
SET TICKET=NEW.COD_TIC;
IF(CAJ_VIEJO <> CAJ_ACTUAL)THEN
SET NEW.NOMB_CAJ = CAJ_ACTUAL;
INSERT INTO REGISTROCAMBIOS (COD_TIC, NOMB_CAJ_ANTIGUO, NOMB_CAJ_NUEVO)
VALUES (TICKET, CAJ_VIEJO, CAJ_ACTUAL);
END IF;
END;
//
DELIMITER ;

#TABLA PARA EL REGISTRO DE CAMBIOS
CREATE TABLE REGISTROCAMBIOS (
ID_REGISTRO INT PRIMARY KEY AUTO_INCREMENT,
FECHA_REGISTRO TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
COD_TIC VARCHAR(20) NOT NULL,
NOMB_CAJ_ANTIGUO VARCHAR(10) NOT NULL,
NOMB_CAJ_NUEVO VARCHAR(10) NOT NULL,
CONSTRAINT CAJERO_ANT FOREIGN KEY (NOMB_CAJ_ANTIGUO) REFERENCES CAJERO(NOMB_CAJ)
ON DELETE NO ACTION ON UPDATE CASCADE,
CONSTRAINT CAJERO_NEW FOREIGN KEY (NOMB_CAJ_NUEVO) REFERENCES CAJERO(NOMB_CAJ)
ON DELETE NO ACTION ON UPDATE CASCADE
);

#COMPROBACION DEL TRIGGER
INSERT INTO TICKET (COD_TIC,NOMB_CAJ,EFECTIVO,FECHA_HORA)
VALUES('017', 'JULIO', 1, CURRENT_TIMESTAMP);

INSERT INTO TIC_ART(COD_ART, COD_TIC, UDS) 
VALUES('009','017', 1);

#COMPROBAR LOS CAMBIOS EN REGISTROCAMBIOS 
SELECT * FROM REGISTROCAMBIOS R WHERE R.COD_TIC ='017';

/*CREAR UN PROCEDIMIENTO ALMACENADO QUE RECIBA UN CÓDIGO DE
 * TICKET Y SOBRESCRIBE EL NOMBRE DEL VENDEDOR QUE FIGURA EN
 * EL MISMO CON EL NOMBRE DEL VENDEDOR QUE ESTABA UTILIZANDO
 * LA CAJA EN EL MOMENTO EN QUE SE EMITIÓ, EN CASO DE QUE 
 * AMBOS SEAN DISTINTOS. ESTA MODIFICACIÓN, DE PRODUCIRSE,
 * DEBE QUEDAR GUARDADA(TICKET, VENDEDORANTERIOR, 
 * NUEVOVENDEDOR, FECHAREGISTRO)EN UNA NUEVA TABLA DE 
 * REGISTRO. INDICAR TAMBIÉN EL SQL NECESARIO PARA CREAR 
 * DICHA TABLA.
 * */
#AJUSTA EL VENDEDOR UNA VEZ QUE SE HAYA CERRADO LA CAJA(DANI'S VERSION)
DELIMITER //
DROP PROCEDURE IF EXISTS AJUSTAVENDEDORTICKET //
CREATE PROCEDURE AJUSTAVENDEDORTICKET ( IN TICKET VARCHAR(20) )
BEGIN
DECLARE VENDEDORANT, VENDEDORNUEVO VARCHAR(10);
DECLARE FECHATICKET TIMESTAMP;
SELECT NOMB_CAJ, FECHA_HORA INTO VENDEDORANT, FECHATICKET FROM TICKET WHERE COD_TIC = TICKET;
SELECT NOMB_CAJ INTO VENDEDORNUEVO FROM REG_CAJA WHERE FECHATICKET BETWEEN F_INICIO AND F_FIN;
IF VENDEDORANT <> VENDEDORNUEVO THEN
INSERT INTO REGISTROCAMBIOS (COD_TIC, NOMB_CAJ_ANTIGUO, NOMB_CAJ_NUEVO)
VALUES (TICKET, VENDEDORANT, VENDEDORNUEVO);
UPDATE TICKET SET NOMB_CAJ = VENDEDORNUEVO WHERE COD_TIC = TICKET;
END IF;
END;
//
DELIMITER ;

#MUESTRA PRIMERO EL CAJERO DEL TICKET 013 SIN AJUSTAR Y LUEGO AJUSTADO
SELECT T.COD_TIC, T.NOMB_CAJ AS CAJ_ANTES_AJUSTE FROM TICKET T WHERE T.COD_TIC ='013'; 
CALL AJUSTAVENDEDORTICKET('013'); 
SELECT T.COD_TIC, T.NOMB_CAJ AS CAJ_DESP_AJUSTE FROM TICKET T WHERE T.COD_TIC ='013'; 

#MUESTRA LOS CAMBIOS EN REGISTROCAJA
SELECT * FROM REGISTROCAMBIOS R WHERE R.COD_TIC ='013';


/*MODIFICAR LA INFORMACIÓN QUE SE GUARDA DE CADA ARTÍCULO PARA AÑADIR
 * EL PORCENTAJE DE IVA QUE LE CORRESPONDE, PONIENDO 21% A LOS YA EXISTENTES.
 */

# LA INFORMACIÓN DEL IVA SE AÑADE COMO NUEVO CAMPO A LA TABLA ARTÍCULO.
ALTER TABLE ARTICULO ADD IVA REAL DEFAULT 0.21;

# A CONTINUACIÓN, PONEMOS 21% A LOS YA EXISTENTES.
UPDATE ARTICULO SET IVA = 0.21;

# CAMBIAMOS LA DEFINICIÓN DEL CAMPO PARA NO PERMITIR VALORES NULOS.
ALTER TABLE ARTICULO ADD CONSTRAINT IVA_NO_NULO CHECK (IVA IS NOT NULL);

#COMPROBACION DE QUE ARTICULO YA TIENE PRECIO IVA
SELECT * FROM ARTICULO A;


/*CREAR UNA VISTA QUE MUESTRE PARA CADA TICKET ÚNICAMENTE LA
 * INFORMACIÓN CORRESPONDIENTE A LA FECHA Y A SU IMPORTE TOTAL, 
 * DESGLOSADO EN BASE E IVA
 * */
DROP VIEW IF EXISTS RESUMENTICKET ;

CREATE VIEW RESUMENTICKET AS
SELECT T.FECHA_HORA AS FECHA, CONCAT(SUM(TA.UDS * A.PVENTA), "") AS IMPORTE,
FORMAT(SUM(TA.UDS * A.PVENTA * A.IVA / (1 + A.IVA)),2) AS IMPORTE_IVA,
FORMAT(SUM(TA.UDS * A.PVENTA / (1 + A.IVA)),2) AS IMPORTE_BASE
FROM TICKET T, TIC_ART TA, ARTICULO A WHERE A.COD_ART = TA.COD_ART AND T.COD_TIC = TA.COD_TIC GROUP BY T.COD_TIC ;


/*CREAR TRES ROLES EN LA BD: ADMIN, CAJERO Y SUPERVISOR. 
 * DEFINIR PERMISOS SOBRE LA BD DE FORMA QUE LOS USUARIOS 
 * CON EL ROL CAJERO PUEDAN INTRODUCIR, BORRAR Y ACTUALIZAR 
 * LA INFORMACIÓN CORRESPONDIENTE A LAS VENTAS; LOS USUARIOS 
 * DEL ROL SUPERVISOR ÚNICAMENTE PODRÁN ACCEDER A LA 
 * INFORMACIÓN QUE PROPORCIONA LA VISTA CREADA EN EL PASO 
 * ANTERIOR. LOS USUARIOS DEL ROL ADMIN TIENEN ACCESO TOTAL 
 * A LA BD
*/
DROP ROLE IF EXISTS ADMINISTRADOR;
DROP ROLE IF EXISTS CAJERO;
DROP ROLE IF EXISTS SUPERVISOR;

CREATE ROLE ADMINISTRADOR;
CREATE ROLE CAJERO;
CREATE ROLE SUPERVISOR;

GRANT ALL PRIVILEGES ON ARTICULO TO ADMINISTRADOR;
GRANT ALL PRIVILEGES ON CAJERO TO ADMINISTRADOR;
GRANT ALL PRIVILEGES ON REG_CAJA TO ADMINISTRADOR;
GRANT ALL PRIVILEGES ON TIC_ART TO ADMINISTRADOR;
GRANT ALL PRIVILEGES ON TICKET TO ADMINISTRADOR;
GRANT ALL PRIVILEGES ON REGISTROCAMBIOS TO ADMINISTRADOR;
GRANT ALL PRIVILEGES ON RESUMENTICKET TO ADMINISTRADOR;

GRANT SELECT, INSERT, DELETE, UPDATE ON TICKET TO CAJERO;
GRANT SELECT, INSERT, DELETE, UPDATE ON TIC_ART TO CAJERO;

GRANT ALL PRIVILEGES ON RESUMENTICKET TO SUPERVISOR;


/*PROGRAMAR UNA FUNCIÓN QUE OBTENGA EL NOMBRE DEL USUARIO QUE 
 * ESTÁ USANDO LA CAJA EN EL MOMENTO ACTUAL, Y OTRO QUE 
 * DEVUELVA EL NOMBRE DEL ÚLTIMO USUARIO QUE USÓ LA CAJA SI NO 
 * HAY NADIE USÁNDOLA (SI ESTÁ ABIERTA DEBE DEVOLVER NULL).
 * */

#NOTA:EL USUARIO EN EL MOMENTO ACTUAL YA ESTÁ DEFINIDO MÁS ARRIBA EN USUARIOACTUAL();

# PARA OBTENER EL ÚLTIMO USUARIO QUE UTILIZÓ LA CAJA, BUSCAMOS EL REGISTRO CON LA MAYOR F_FIN:
#NO SE PIDE PERO QUEDA POR AQUI (DANI´S VERSION)
DELIMITER //
DROP FUNCTION IF EXISTS USUARIOANTERIOR //
CREATE FUNCTION USUARIOANTERIOR()
RETURNS VARCHAR(10)
BEGIN
DECLARE USUARIO VARCHAR(10);
SELECT NOMB_CAJ INTO USUARIO FROM REG_CAJA WHERE F_FIN = (SELECT MAX(F_FIN) FROM REG_CAJA);
RETURN USUARIO;
END;
//
DELIMITER ;

#NOTA: los nulos no se comprueban en esta version
#comprobación de la dani's version
select c.NOMB_CAJ from cajero c where c.NOMB_CAJ= USUARIOANTERIOR();

#ESTE ES IGUAL AL DE ARRIBA PERO SI HAY ALGUNA FECHA DE FIN NULL DEVUELVE NULL 
#ESTA ES LA QUE PIDE EL ENUNCIADO
DELIMITER //
DROP FUNCTION IF EXISTS USUARIOANTERIOR2 //
CREATE FUNCTION USUARIOANTERIOR2()
RETURNS VARCHAR(10)
BEGIN
DECLARE ULTIMO VARCHAR(10);
DECLARE AUX VARCHAR(10);
SELECT RC.NOMB_CAJ INTO ULTIMO FROM REG_CAJA RC WHERE RC.F_FIN = (SELECT MAX(RC2.F_FIN) FROM REG_CAJA RC2);
SELECT RC.NOMB_CAJ INTO AUX FROM REG_CAJA RC WHERE RC.F_FIN IS NULL LIMIT 1;
IF AUX IS NOT NULL THEN
SET ULTIMO = NULL;
END IF;
RETURN ULTIMO;
END;
//
DELIMITER ;

#comprobacion de la version que se pide en el enunciado
select c.NOMB_CAJ from cajero c where c.NOMB_CAJ= USUARIOANTERIOR2();


/*AÑADIR UN MECANISMO PARA QUE, CADA VEZ QUE LA CAJA SE ASIGNE A UN USUARIO, A ÉSTE
LE SEA ASIGNADO EN ESE MOMENTO EL ROL CAJERO; ESTE ROL LE DEBE SER RETIRADO CUANDO EL
USUARIO YA NO TENGA ASIGNADA LA CAJA*/

# PARA ASIGNAR DE FORMA AUTOMÁTICA EL ROL CAJERO, CREAMOS UN TRIGGER SOBRE LAS INSERCIONES QUE SE REALICEN EN LA TABLA REG_CAJA:
DELIMITER //
DROP TRIGGER IF EXISTS HABILITACAJERO //
CREATE TRIGGER HABILITACAJERO
AFTER INSERT ON REG_CAJA
FOR EACH ROW
BEGIN
DECLARE GRT VARCHAR(50);
SET GRT = ' GRANT CAJERO TO ' OR NEW.NOMB_CAJ OR ';';
CALL GRT;
END;
//
DELIMITER ;

/*QUITAR PRIVILEGIOS AL CAJERO CUANDO SE DA DE BAJA*/
DELIMITER //
DROP TRIGGER IF EXISTS DESHABILITACAJERO //
CREATE TRIGGER DESHABILITACAJERO
AFTER UPDATE ON REG_CAJA
FOR EACH ROW
IF NEW.F_FIN IS NOT NULL THEN
BEGIN
DECLARE RVK VARCHAR(50);
SET RVK=' REVOKE CAJERO TO ' OR OLD.NOMB_CAJ OR ';';
CALL RVK;
END;
END IF;
//
DELIMITER ;


/*CREAR UNA NUEVA TABLA PEDIDO, QUE ALMACENA PARA CADA ARTÍCULO EL NÚMERO DE UDS QUE SE PIDEN, 
 *LA FECHA EN QUE SE REGISTRA EL PEDIDO, LA FECHA EN QUE SE LLEVA A CABO, Y LA FECHA EN QUE SE 
 *RECIBE. ESTOS DOS ÚLTIMOS CAMPOS TENDRÁN VALOR NULL MIENTRAS NO SE PIDE Y RECIBE EL ARTÍCULO, 
 *RESPECTIVAMENTE.*/

CREATE TABLE PEDIDO(
ID INT AUTO_INCREMENT,
ARTICULO VARCHAR(10)NOT NULL,
UDS_PED INT NOT NULL,
FECHA_CABO TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
FECHA_REGISTRO TIMESTAMP DEFAULT NULL,
FECHA_RECIBO TIMESTAMP DEFAULT NULL,

PRIMARY KEY (ID),

FOREIGN KEY (ARTICULO)REFERENCES ARTICULO(COD_ART)
ON DELETE RESTRICT
ON UPDATE CASCADE
);


/*AÑADIR A CADA ARTÍCULO UN CAMPO QUE INDIQUE EL NÚMERO DE UDS ÓPTIMO 
 *QUE SE DEBEN TENER EN TIENDA DEL MISMO (POR DEFECTO 6)
 */

ALTER TABLE ARTICULO ADD UDS_OPTIMAS INT DEFAULT 6;
UPDATE ARTICULO SET UDS_OPTIMAS = 6;
ALTER TABLE  ARTICULO ADD CONSTRAINT UDS_NOT_NULL CHECK (UDS_OPTIMAS IS NOT NULL);


#comprobación
select * from articulo a ;


/*CREAR UN PROCEDIMIENTO NUEVO QUE REGISTRE PARA CADA ARTÍCULO CON X O MENOS UDS DISPONIBLES(X ES UN VALOR VARIABLE)
UNA NUEVA LÍNEA DE PEDIDO POR TANTAS UDS COMO HAGAN FALTA PARA ALCANZAR LAS UDS ÓPTIMAS.
SE DEBE TENER EN CUENTA QUE YA PUEDE EXISTIR UN PEDIDO PARA ESE ARTÍCULO PENDIENTE DE SER LLEVADO A CABO. EN ESE CASO,
SOLAMENTE SE DEBERÁ AJUSTAR EL NÚMERO DE UDS A PEDIR.*/

DELIMITER //
DROP PROCEDURE IF EXISTS AUTOPEDIDO //
CREATE PROCEDURE AUTOPEDIDO(IN ART VARCHAR(10))
	BEGIN
		DECLARE UDS_OP, UDS_D, UDS_P INT;
		SELECT UDS_OPTIMAS INTO UDS_OP FROM ARTICULO A WHERE A.COD_ART=ART; 
		SELECT UDS INTO UDS_D FROM ARTICULO A WHERE A.COD_ART=ART;
		SELECT SUM(UDS_PED) INTO UDS_P FROM PEDIDO P WHERE P.ARTICULO=ART AND FECHA_RECIBO IS NULL;
		IF (UDS_P IS NULL) THEN
			SET UDS_P := 0;
		END IF;
		IF (UDS_OP > (UDS_D + UDS_P)) THEN
			INSERT INTO PEDIDO (ARTICULO, UDS_PED) VALUES ( ART, UDS_OP - ( UDS_D + UDS_P) );
		END IF;
	END;
//
DELIMITER ;

DELIMITER //
DROP PROCEDURE IF EXISTS COMPRUEBAARTICULOS //
CREATE PROCEDURE COMPRUEBAARTICULOS()
	BEGIN
		DECLARE ART_TOT, CONT INT;
		DECLARE ID_VUELTA VARCHAR(10);
		SELECT COUNT(A.COD_ART) INTO ART_TOT FROM ARTICULO A;
		SET CONT =1;
		WHILE CONT <= ART_TOT DO
			SELECT CLAVE INTO ID_VUELTA FROM (SELECT ROW_NUMBER() OVER (ORDER BY COD_ART)LINEA, COD_ART AS CLAVE FROM ARTICULO A ORDER BY A.COD_ART)AS T2 WHERE T2.LINEA=CONT;
			CALL AUTOPEDIDO(ID_VUELTA);
			SET CONT = CONT +1;
		END WHILE;
	END;
//
DELIMITER ;
CALL COMPRUEBAARTICULOS(); 

#comprobacion en la tabla pedidos:
select * from pedido p;


/*CREAR UN DISPARADOR QUE REGISTRE UN NUEVO PEDIDO DE UN ARTÍCULO CUANDO 
 *LA TIENDA SE QUEDE SIN STOCK O CON SOLO UNA UNIDAD DEL MISMO.
 */

DELIMITER //
DROP PROCEDURE IF EXISTS AUTOPEDIDOUNICO//
CREATE PROCEDURE AUTOPEDIDOUNICO(IN ART VARCHAR(10))
	BEGIN
		DECLARE UDS_OP, UDS_D, UDS_P INT;
		SELECT UDS_OPTIMAS INTO UDS_OP FROM ARTICULO A WHERE A.COD_ART=ART; 
		SELECT UDS INTO UDS_D FROM ARTICULO A WHERE A.COD_ART=ART;
		SELECT SUM(UDS_PED) INTO UDS_P FROM PEDIDO P WHERE P.ARTICULO=ART AND FECHA_RECIBO IS NULL;
		IF (UDS_P IS NULL) THEN
			SET UDS_P := 0;
		END IF;
		IF ((UDS_D + UDS_P)<=1) THEN
			INSERT INTO PEDIDO (ARTICULO, UDS_PED) VALUES ( ART, UDS_OP - ( UDS_D + UDS_P) );
		END IF;
	END;
//
DELIMITER ;

DELIMITER //
DROP TRIGGER IF EXISTS INSERT_TICKET_ARTICULO //

CREATE TRIGGER INSERT_TICKET_ARTICULO
	AFTER INSERT ON TIC_ART
	FOR EACH ROW
	BEGIN 
		DECLARE ARTCHECK VARCHAR(10);
		DECLARE UDSTICKET, STOCK INT;
		SET ARTCHECK=NEW.COD_ART;
		SET UDSTICKET=NEW.UDS;
		SELECT UDS INTO STOCK FROM ARTICULO A WHERE A.COD_ART=ARTCHECK;
		IF STOCK < UDSTICKET THEN
			DELETE FROM TIC_ART TA WHERE TA.COD_ART =NEW.COD_ART AND TA.COD_TIC = NEW.COD_TIC;
		ELSE
			UPDATE ARTICULO A SET UDS = UDS - UDSTICKET WHERE A.COD_ART = ARTCHECK;
			CALL AUTOPEDIDOUNICO(ARTCHECK);
		END IF;
	END;
//
DELIMITER ;

insert into articulo (COD_ART,DESCRIP,UDS,PVENTA)
values('012', 'billar', '2', 150);

insert into ticket (COD_TIC,NOMB_CAJ,EFECTIVO,FECHA_HORA)
values('018',USUARIOACTUAL(), 0, CURRENT_TIMESTAMP);

insert into tic_art (COD_ART,COD_TIC,UDS)
values ('012','018', 1);

select * from pedido p where p.ARTICULO = '012';


/*CREAR UN PROCEDIMIENTO QUE PONGA COMO RECIBIDO CON LA FECHA ACTUAL EL PEDIDO DE UN
ARTÍCULO DADO, AUMENTANDO EL STOCK DEL MISMO EN EL NÚMERO DE UDS RECIBIDAS*/

#esto es un tigre que nos equivocamos. Pasa de el que queda de repaso
/*
 * DELIMITER //
DROP TRIGGER IF EXISTS PEDIDOLLEGADO //
CREATE TRIGGER PEDIDOLLEGADO
AFTER UPDATE ON PEDIDO
FOR EACH ROW
BEGIN
	DECLARE UDS_ANHADIR INT;
	IF NEW.FECHA_RECIBO IS NOT NULL THEN
		SET UDS_ANHADIR=NEW.UDS_PED;
		UPDATE ARTICULO A SET UDS = A.UDS + UDS_ANHADIR WHERE A.COD_ART = NEW.ARTICULO;
	END IF;
END;
//
DELIMITER ;
*/

DELIMITER //
drop procedure if exists PEDIDO_RECIBIDO //
create procedure PEDIDO_RECIBIDO (in ID_REC INT)
begin
	declare ART_PED VARCHAR(10);
	declare CANT_PED INT;
	update PEDIDO set FECHA_RECIBO = current_timestamp();
	select p.UDS_PED into CANT_PED from pedido p where p.ID = ID_REC;
	select p.ARTICULO into ART_PED from pedido p where p.ID = id_rec;
	update articulo A set A.UDS = A.UDS + CANT_PED where A.COD_ART = ART_PED; 
end;
//
DELIMITER ;

insert into pedido (ARTICULO,UDS_PED,FECHA_CABO)
values ('005',100,current_date);
select * from pedido;
select * from articulo a where a.COD_ART ='005';
call PEDIDO_RECIBIDO(4);
select * from pedido;
select * from articulo a where a.COD_ART ='005'; 